(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{175:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"缓存架构设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存架构设计","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存架构设计")]),t._v(" "),s("p",[t._v("核心原则："),s("code",[t._v("读多写少的数据，缓存起来，减少数据库访问，提升性能")])]),t._v(" "),s("h2",{attrs:{id:"实体缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实体缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 实体缓存")]),t._v(" "),s("p",[t._v("实体缓存就是"),s("code",[t._v("整表缓存那些读取很多修改极少的数据")]),t._v("，用于系统参数表、栏目分类表等。"),s("br"),t._v("\n实体类内使用'Meta.Cache.Entities'即可触发使用实体缓存，内部将执行一次查询（'Select * From Table'）加载整表数据为实体列表。"),s("br"),t._v(" "),s("code",[t._v("Meta.Cache.Entities")]),t._v("就是这个实体列表，使用缓存实际上就是在这个列表上执行"),s("code",[t._v("Find")]),t._v("/"),s("code",[t._v("FindAll")]),t._v("操作。"),s("br"),t._v("\n基于性能考虑，建议单表数据小于1000行时使用，大于10000时坚决不要使用。")]),t._v(" "),s("p",[t._v("工具生成的实体业务类代码经常可以看到如下代码：")]),t._v(" "),s("div",{staticClass:"language-csharp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-csharp"}},[s("code",[s("span",{attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{attrs:{class:"token class-name"}},[t._v("Student")]),t._v(" "),s("span",{attrs:{class:"token function"}},[t._v("FindByID")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token class-name"}},[t._v("Int32")]),t._v(" id"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id "),s("span",{attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("0")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("null")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Meta"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Count "),s("span",{attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{attrs:{class:"token number"}},[t._v("1000")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{attrs:{class:"token function"}},[t._v("Find")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ID"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" id"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{attrs:{class:"token comment"}},[t._v("// 实体缓存")]),t._v("\n        "),s("span",{attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Meta"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Cache"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Entities"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{attrs:{class:"token function"}},[t._v("Find")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ID"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" id"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("因此，"),s("code",[t._v("FindByID")]),t._v("在该表数据小于1000时，其实是使用实体缓存。")]),t._v(" "),s("p",[t._v("缓存默认过期时间"),s("code",[t._v("60秒")]),t._v("，过期后使用仍然是马上返回旧数据，同时开启异步查询更新缓存。"),s("br"),t._v("\n任何添删改等改动数据库的操作，都将会让缓存马上过期，并启动异步更新。"),s("br"),t._v("\n任何添删改操作，都将实时修改缓存，即使在异步更新完成之前，从缓存拿到的也是最新数据。除非有其它进程更新了数据表，此时需要等缓存的异步更新操作完成才能得到最新数据。")]),t._v(" "),s("h2",{attrs:{id:"缓存更新策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存更新策略","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存更新策略")]),t._v(" "),s("p",[t._v("在没有使用事务时，对数据表的任何添删改，将会让该表的实体缓存马上过期，以及清空单对象缓存。"),s("br"),t._v("\n使用事务时，每一个添删改操作仅修改缓存，直到事务提交或回滚才清空缓存。")]),t._v(" "),s("h2",{attrs:{id:"特别优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特别优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 特别优化")]),t._v(" "),s("p",[s("code",[t._v("SQLite")]),t._v("没有索引表供快速查询表行数，而直接"),s("code",[t._v("Select Count")]),t._v("又慢，因此框架针对"),s("code",[t._v("SQLite")]),t._v("进行特别优化。"),s("br"),t._v("\n获取表行数时，如果有自增字段，首先获取其最大值临时充当表行数，然后启动异步查询"),s("code",[t._v("Select Count")]),t._v("以获取精确的表行数。"),s("br"),t._v("\n因此，"),s("code",[t._v("SQLite")]),t._v("使用"),s("code",[t._v("Meta.Count")]),t._v("时，第一次得到的数据可能有偏差，一会后即可得到精确数据。时间的长度主要由数据表大小决定，一百万数据大概需要几百毫秒。该偏差完全可以通过系统启动时进行系统预热来对冲掉。")])])}],!1,null,null,null);a.default=e.exports}}]);